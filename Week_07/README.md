学习笔记  
####字典树(Trie树)
又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串(但不仅  
限于字符串)，所以经常被搜索引擎系统用于文本字频统计。  
优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。  

性质：  
1、结点本身不存完整单词  
2、从根节点到某一节点，路径上经过的字符链接起来，为该节点的字符串。  
3、每个节点的所有子节点路径代表的字符都不相同。  

叶子节点可能存在其他信息，比如计数信息等。  

核心思想：空间换时间；利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的  


分析单词搜索 2 用 Tire 树方式实现的时间复杂度：  
N:单词个数，I*J的字符矩阵，平均单词长度K
构建前缀树：O(N*K)
每个字符Trie树搜索：最多为4*K次
字符矩阵遍历:O（I*J）  
综上时间复杂度为：O（I*J*4*K） + O(N*K)  

####并查集 
适用场景：组团和配对问题。  
基本操作：
makeSet（s）：建立一个新的并查集，其中包含s个氮元素集合  
unionSet(x,y):把元素x和元素y所在的集合合并，要求x和y所在   
的集合不相交，如果相交则不合并。  
find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个  
元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。  
```java
class UnionFind{
    //集合个数
    private int count;
    private int[] parent;
    
    //初始化并查集元素
    private UnionFind(int n){
        //开始时个数为数组长度，即每个元素自个就是一个集合。
        count = n;
        parent = new int[n];
        //标记每个元素的集合管理者为自己。
        for(int i = 0; i < n ; i++) {
          parent[i] = i;
        }
    }   

    //查找元素所在集合的管理者
    public int find(int p){
        //循环查找，截止为集合的管理者就是自己。
        while(p != parent[p]){ 
            parent[p] = parent[parent[p]]; //置换一次管理者，相当于一次搜索长度优化
            p = parent[p];
        }
        return p;
    }

    //元素聚合
    public void union(int p,int q){
        //查找元素各自所在集合的管理者，
        int rootP = find(p);
        int rootQ = find(q);
        //管理者相等，说明在同一个集合无需合并
        if(rootP == rootQ){
            return;
        }
        //不在同一个集合，则修改任一一个元素的所在集合的
        //管理者为另一个元素的管理者
        parent[rootP] = rootQ;
        //发生了合并集合数减一
        count--;
    }

}
```
个人理解：先定义，并查集是一种数据结构，解决了根据规则元素分组  
和配对的问题。

####剪枝
个人理解：剪枝是对之前搜索的一种优化思路。可以说这几主要复习BFS，  
DFS,回溯，递归等的过程和特点。  

####双向BFS
个人理解：双向BFS，解决查找图相遇问题，从起始结点和终止结点同时搜索  
减少了一半的时间，
```java
//代码模板
class DBFS{
    
}
```
####启发式搜索（A*搜索）
个人理解：BFS，DFS搜索的优化，每次搜索是引入PriorityQueue（优先队列）  
根据具体问题，设置优先队列的条件 
```java
//代码模板，以二叉树为例，可以为图
class PriorityQueueBFS{
    private PriorityQueue<TreeNode> queue;
    
    public void aStarSearch(TreeNode node){
        //这里实现comparator来进行优先级的确定
        queue = new PriorityQueue<>(new Comparator<TreeNode>(){
            public int compare(TreeNode o1, TreeNode o2){
                return o1.val - o2.val;
            }   

        }); 
        queue.offer(node);
        while(queue.size() != 0){
            TreeNode node = queue.poll();
            //处理数据
            
            //加入相关节点
            queue.offer(node.left);
            queue.offer(node.right);
        }

    }   

}
```
启发式函数：h(n),它用来评价哪些结点是最有希望的是一个我们  
要找的结点，H(n)会返回一个非负实数，也可以认为是从结点n的  
目标结点路径的估计成本。  
启发式函数是一种告知搜素方向的方法。它提供了一种明智的方法  
来猜测那个邻居节点会导向一个目标。  

解题技巧：对于部分移位或者搜索方向的问题，可以抽象移位或者  
方向数组  

####AVL树和红黑树的实现和特性
AVL树：AVL树出现的原因就是树的搜索时间复杂度由树的高度来决定    
平衡因子{-1，0,1}  
左旋：  
右旋：  
左右旋：  
右左旋：  
不足：结点需要存储额外的信息，并且调整次数频繁  

红黑树：一种近似平衡的二叉搜索树，它能够确保任何一个结点的左右  
子树的高度差小于两倍。  
性质：  
1、每个结点要么红，要么黑  
2、根结点为黑  
3、每个叶子结点（空结点）是黑色  
4、不能有相邻的两个红色结点  
5、从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。   

比较：
1、AVL需要更多的内存存储结点信息，红黑树只需要记录红黑属性。  
2、AVL查询更快，红黑树插入和删除更快。  
3、红黑树多用于库实现中，AVL多用于数据库中。  


个人总结：  
很多问题可以转换为树的搜索问题，将问题解决过程中产生的结果作为  
中间状态，也就是搜索每个状态是否满足目标解，满足则是树搜索完成。  
这也可能就是为什么部分博主建议多联系树基本操作和相关的问题的原  
因。
