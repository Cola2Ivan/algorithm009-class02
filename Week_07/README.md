学习笔记  
####字典树(Trie树)
又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串(但不仅  
限于字符串)，所以经常被搜索引擎系统用于文本字频统计。  
优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。  

性质：  
1、结点本身不存完整单词  
2、从根节点到某一节点，路径上经过的字符链接起来，为该节点的字符串。  
3、每个节点的所有子节点路径代表的字符都不相同。  

叶子节点可能存在其他信息，比如计数信息等。  

核心思想：空间换时间；利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的  


分析单词搜索 2 用 Tire 树方式实现的时间复杂度：  
N:单词个数，I*J的字符矩阵，平均单词长度K
构建前缀树：O(N*K)
每个字符Trie树搜索：最多为4*K次
字符矩阵遍历:O（I*J）  
综上时间复杂度为：O（I*J*4*K） + O(N*K)  

####并查集 
适用场景：组团和配对问题。  
基本操作：
makeSet（s）：建立一个新的并查集，其中包含s个氮元素集合  
unionSet(x,y):把元素x和元素y所在的集合合并，要求x和y所在   
的集合不相交，如果相交则不合并。  
find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个  
元素是否位于同一个集合，只要将他们各自的代表比较一下就可以了。  
```java
class UnionFind{
    //集合个数
    private int count;
    private int[] parent;
    
    //初始化并查集元素
    private UnionFind(int n){
        //开始时个数为数组长度，即每个元素自个就是一个集合。
        count = n;
        parent = new int[n];
        //标记每个元素的集合管理者为自己。
        for(int i = 0; i < n ; i++) {
          parent[i] = i;
        }
    }   

    //查找元素所在集合的管理者
    public int find(int p){
        //循环查找，截止为集合的管理者就是自己。
        while(p != parent[p]){ 
            parent[p] = parent[parent[p]]; //置换一次管理者，相当于一次搜索长度优化
            p = parent[p];
        }
        return p;
    }

    //元素聚合
    public void union(int p,int q){
        //查找元素各自所在集合的管理者，
        int rootP = find(p);
        int rootQ = find(q);
        //管理者相等，说明在同一个集合无需合并
        if(rootP == rootQ){
            return;
        }
        //不在同一个集合，则修改任一一个元素的所在集合的
        //管理者为另一个元素的管理者
        parent[rootP] = rootQ;
        //发生了合并集合数减一
        count--;
    }

}
```
个人理解：先定义，并查集是一种数据结构，解决了根据规则元素分组  
和配对的问题。

####剪枝
个人理解：剪枝是对之前搜索的一种优化思路。可以说这几主要复习BFS，  
DFS,回溯，递归等的过程和特点。
